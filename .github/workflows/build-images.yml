name: Build and Push Container Images

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_REPO_PREFIX: ${{ github.repository }}

jobs:
  # Job to define images to build
  images-to-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read # For actions/checkout
      packages: write # For pushing images to GHCR
      id-token: write # For Sigstore/Cosign for OIDC

    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      should_push: ${{ steps.set.outputs.should_push }}

    steps:
      - id: set
        run: |
          echo "GITHUB_REF=$GITHUB_REF"
          if [[ "${GITHUB_REF}" == "refs/heads/main" || "${GITHUB_REF}" == refs/tags/v* ]]; then
            echo "should_push=true" >> $GITHUB_OUTPUT
          else
            echo "should_push=false" >> $GITHUB_OUTPUT
          fi
      - name: Checkout current repository
        uses: actions/checkout@v4

      - name: Install yq and jq
        run: |
          #sudo snap install yq
          sudo apt-get update && sudo apt-get install -y jq yq

      - name: Generate build matrix from specs and local images
        id: generate-matrix
        run: |
          #!/usr/bin/env bash
          set -eo pipefail

          # Initialize an empty JSON array
          MATRIX_JSON="[]"

          # --- Process external images from specs/ ---
          for SPEC_FILE in specs/*.y*ml; do
            echo "Processing external spec: $SPEC_FILE..."
            # Convert YAML to JSON and read values using jq
            while IFS= read -r build_json; do
              #jq --argjson build "$build_json" '. + [$build]' <<< "$MATRIX_JSON"
              MATRIX_JSON=$(jq --argjson build "$build_json" '. + [$build]' <<< "$MATRIX_JSON")
            done <<<$( jq -c '. as $spec |
              $spec.builds[] | . as $build |
              {
                build_type: "external",
                repo_url: $spec.repository,
                repo_ref: (.ref // $spec.ref),
                image_name: .name,
                build_context: ("external_repo/" + .name + "/" + .context),
                dockerfile_path: .dockerfile,
                platforms: (.platforms // "linux/amd64,linux/arm64"),
                image_tags: ((.imageTags // (.ref // $spec.ref)) + ",latest" | split(",") | map($ENV.IMAGE_REPO_PREFIX + "/" + $build.name + ":" + .)),
                build_args: ($build.buildArgs // [])
              }' <(yq '.' "$SPEC_FILE"))
          done

          # --- Process local images from images/ ---
          GIT_TAG=$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)

          for FILE in images/*/*file; do
            echo "Processing ${FILE}..."
            IMAGE_DIR=$(dirname "$FILE")
            FILE_NAME=$(basename "$FILE")

            case $FILE_NAME in
              Containerfile | Dockerfile)
                echo "Found match: $FILE_NAME"
                CONTAINERFILE="${FILE_NAME}"
                ;;
              *)
                echo "Not recognizable: $FILE. Skipping"
                continue
                ;;
            esac

            IMAGE_NAME=$(basename "$IMAGE_DIR")
            BUILD_CONTEXT="${IMAGE_DIR}"
            DOCKERFILE_PATH="${CONTAINERFILE}"

            TAGS_ARRAY=$(jq -n \
              --arg prefix "${IMAGE_REPO_PREFIX}/${IMAGE_NAME}:" \
              --arg tags "$GIT_TAG,latest" \
              '$tags | split(",") | map($prefix + .)'\
            )

            export IMAGE_NAME BUILD_CONTEXT DOCKERFILE_PATH TAGS_ARRAY

            BUILD_JSON=$(jq -n \
              '{
                build_type: "local",
                image_name: $ENV.IMAGE_NAME,
                build_context: $ENV.BUILD_CONTEXT,
                dockerfile_path: $ENV.DOCKERFILE_PATH,
                platforms: "linux/amd64,linux/arm64",
                image_tags: $ENV.TAGS_ARRAY
              }' \
            )
            MATRIX_JSON=$(jq --argjson build "$BUILD_JSON" '. + [$build]' <<< "$MATRIX_JSON")
          done

          echo "Generated Matrix: $MATRIX_JSON"
          COMPACT=$(jq -c '{include: .}' <<< "$MATRIX_JSON")
          echo "matrix=$COMPACT" >> "$GITHUB_OUTPUT"

  # Job to perform the actual builds based on the matrix generated above
  build-and-push:
    needs: images-to-build
    runs-on: ubuntu-latest
    permissions:
      contents: read # For actions/checkout
      packages: write # For pushing images to GHCR
      id-token: write # For Sigstore/Cosign for OIDC
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.images-to-build.outputs.matrix) }}

    steps:
      - name: Checkout current repository
        uses: actions/checkout@v4

      - name: Checkout external repository (${{ matrix.repo_url }})
        if: ${{ matrix.build_type == 'external' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo_url }}
          ref: ${{ matrix.repo_ref }}
          path: external_repo/${{ matrix.image_name }} # Checkout into a unique path

      - name: Install Cosign
        if: needs.images-to-build.outputs.should_push == 'true'
        uses: sigstore/cosign-installer@v3.9.2

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3.6.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.11.1

      - name: Log in to the Container registry
        if: needs.images-to-build.outputs.should_push == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v6
        id: build-and-push
        with:
          context: ${{ matrix.build_context }}
          file: ${{ matrix.dockerfile_path }}
          push: ${{ needs.images-to-build.outputs.should_push == 'true' }}
          platforms: ${{ matrix.platforms }}
          tags: ${{ join(matrix.image_tags, ',') }}
          build-args: ${{ matrix.build_args && join(matrix.build_args, '\n') || '' }}

      - name: Sign the images with GitHub OIDC Token
        if: needs.images-to-build.outputs.should_push == 'true'
        env:
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
          TAGS: ${{ join(matrix.image_tags, ' ') }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          cosign sign --yes ${images}

      - name: Verify the signed image
        if: needs.images-to-build.outputs.should_push == 'true'
        env:
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
          TAGS: ${{ join(matrix.image_tags, ' ') }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          cosign verify ${images} \
          --certificate-oidc-issuer https://token.actions.githubusercontent.com \
          --certificate-identity-regexp="https://github.com/${IMAGE_REPO_PREFIX}" \
          -o text
