name: Build and Push Container Images

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_builds:
        description: "Used to force building all specs and images"
        required: false
        type: boolean
        default: false
      force_push:
        description: "Used to force pushing. Requires to set force_builds to true if no image would otherwise build"
        required: false
        type: boolean
        default: false
env:
  REGISTRY: ghcr.io
  IMAGE_REPO_PREFIX: ghcr.io/${{ github.repository }}
  FORCE_BUILDS: "${{ inputs.force_builds || false }}"
  FORCE_PUSH: "${{ inputs.force_push || false }}"

jobs:
  # Job to define images to build
  images-to-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read # For actions/checkout

    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      should_build: ${{ steps.generate-matrix.outputs.should_build }}
      should_push: ${{ steps.set.outputs.should_push }}

    steps:
      - name: Set whether we should trigger docker push (and cosign)
        id: set
        run: |
          #!/usr/bin/env bash
          set -eo pipefail

          echo "GITHUB_REF=$GITHUB_REF"
          if [[ "${GITHUB_REF}" == "refs/heads/main" || "${GITHUB_REF}" == refs/tags/v* || "${FORCE_PUSH}" == "true" ]]; then
            echo "should_push=true" >> $GITHUB_OUTPUT
          else
            echo "should_push=false" >> $GITHUB_OUTPUT
          fi
      - name: Checkout current repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0 # Needed to fetch full history for git diff

      - name: Install yq and jq
        run: |
          #sudo snap install yq
          sudo apt-get update && sudo apt-get install -y jq yq

      - name: Generate build matrix from specs and local images
        id: generate-matrix
        run: |
          #!/usr/bin/env bash
          set -eo pipefail

          PARENTS=$(git rev-list --parents -n 1 HEAD)
          PARENT_COUNT=$(echo $PARENTS | wc -w)
          # --diff-filter=ACDMRT: includes Added, Copied, Deleted, Modified, Renamed, and Type-changed files.
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CHANGED_FILES=$(git diff --name-only --diff-filter=ACDMRT origin/main...HEAD)
          elif [[ "$PARENT_COUNT" -eq 2 ]]; then
            # Single parent: squash merge or direct commit
            CHANGED_FILES=$(git diff --name-only --diff-filter=ACDMRT HEAD^ HEAD)
          elif [[ "$PARENT_COUNT" -eq 3 ]]; then
            # Two parents: true merge commit
            BASE=$(git merge-base HEAD^1 HEAD^2)
            CHANGED_FILES=$(git diff --name-only --diff-filter=ACDMRT "$BASE" HEAD)
          else
            echo "Unexpected number of parents in HEAD: $PARENT_COUNT"
          fi

          # Use git diff to get a list of changed files.
          # --diff-filter=ACDMRT: includes Added, Copied, Deleted, Modified, Renamed, and Type-changed files.
          # The output is a newline-separated list of filenames.
          # CHANGED_FILES=$(git diff --name-only --diff-filter=ACDMRT $BASE_SHA $HEAD_SHA)
          echo "Changed Files to process: $CHANGED_FILES"

          # Decide if we should build images
          if [[ -z "${CHANGED_FILES}" && "${FORCE_BUILDS}" == "false" ]]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "should_build=true" >> $GITHUB_OUTPUT
            if [[ "${FORCE_BUILDS}" == "false" ]]; then
              # Set specs - specs are only y*ml and right under 'specs/'
              CHANGED_SPECS=$(echo "$CHANGED_FILES" | grep -E '^specs/[^/]*\.(yml|yaml)$' || true)
              # Set local builds - any file changed under 'images/' will collect the image dir, always right under 'images/'
              CHANGED_IMAGES=$(echo "$CHANGED_FILES" | grep -E '^images/' || true | while read -r line; do dirname "$line"; done | uniq)
            else
              # Set specs - specs are all of the y*ml right under 'specs/' - As an array
              CHANGED_SPECS=(specs/*.y*ml)
              # Set local builds - all directories under 'images/' - As an array
              CHANGED_IMAGES=(images/*)
            fi
          fi

          # Initialize an empty JSON array
          MATRIX_JSON="[]"

          # --- Process external images from specs/ ---
          # Filter changed specs

          DATE_VER="0.0.$(date +%Y%m%d)-${{ github.run_number }}.${{ github.run_attempt }}"
          export DATE_VER

          for SPEC_FILE in ${CHANGED_SPECS[@]}; do
            echo "Processing external spec: $SPEC_FILE..."
            # Convert YAML to JSON and read values using jq
            while IFS= read -r build_json; do
              #jq --argjson build "$build_json" '. + [$build]' <<< "$MATRIX_JSON"
              MATRIX_JSON=$(jq --argjson build "$build_json" '. + [$build]' <<< "$MATRIX_JSON")
            done <<<$( jq -c '. as $spec |
              $spec.builds[] | . as $build |
              {
                build_type: "external",
                repo_url: $spec.repository,
                repo_ref: (.ref // $spec.ref),
                image_name: .name,
                build_context: ($build.context // "." ),
                dockerfile_path: ($build.dockerfile // "Dockerfile"),
                platforms: (.platforms // "linux/amd64,linux/arm64"),
                image_tags: ((.imageTags // (.ref // $spec.ref)) + ",latest" | split(",") |
                  map(if . == "DATE" then $ENV.DATE_VER else . end) |
                  map(if . == "REF" then ($build.ref // $spec.ref) else . end) |
                  map($ENV.IMAGE_REPO_PREFIX + "/" + $build.name + ":" + .)),
                version: ((.imageTags // (.ref // $spec.ref)) | split(",") |
                  map(if . == "DATE" then $ENV.DATE_VER else . end) |
                  map(if . == "REF" then ($build.ref // $spec.ref) else . end) |
                  .[0]),
                image: ($ENV.IMAGE_REPO_PREFIX + "/" + $build.name),
                build_args: ($build.buildArgs // [])
              }' <(yq '.' "$SPEC_FILE"))
          done

          # --- Process local images from images/ ---
          GIT_TAG=$(git describe --tags --exact-match 2>/dev/null || echo $DATE_VER)

          for DIR in ${CHANGED_IMAGES[@]}; do
            echo "Processing ${DIR}..."
            IMAGE_DIR="${DIR}"
            # Only build local for dirs with Docker|Containerfile
            if [[ -f "${DIR}/Dockerfile" ]]; then
              FILE="${DIR}/Dockerfile"
              echo "Found match: $FILE"
            elif [[ -f "${DIR}/Containerfile" ]]; then
              FILE="${DIR}/Containerfile"
              echo "Found match: $FILE"
            else
              echo "Found no Containerfile or Dockerfile. Skipping ${DIR}"
              continue
            fi

            if [[ -f "${DIR}/.version" ]]; then
              VERSION_LINE=$(<"${DIR}/.version")
              VERSION="${VERSION_LINE//*=}"
            fi
            if [[ -n $VERSION ]]; then
              GIT_TAGS="${VERSION},${GIT_TAG},latest"
            else
              GIT_TAGS="${GIT_TAG},latest"
            fi

            IMAGE_NAME=$(basename "$IMAGE_DIR")
            BUILD_CONTEXT="${IMAGE_DIR}"
            DOCKERFILE_PATH="${FILE}"

            export IMAGE_NAME BUILD_CONTEXT DOCKERFILE_PATH GIT_TAGS

            BUILD_JSON=$(jq -n \
              '{
                build_type: "local",
                repo_url: "${{ github.server_url }}/${{ github.repository }}",
                repo_ref: "${{ endsWith( '/merge', github.ref_name ) && github.head_ref || github.ref_name }}",
                image_name: $ENV.IMAGE_NAME,
                build_context: $ENV.BUILD_CONTEXT,
                dockerfile_path: $ENV.DOCKERFILE_PATH,
                platforms: "linux/amd64,linux/arm64",
                image_tags: ($ENV.GIT_TAGS | split(",") | map($ENV.IMAGE_REPO_PREFIX + "/" + $ENV.IMAGE_NAME + ":" + .)),
                version: ($ENV.GIT_TAGS | split(",") | .[0]),
                image: ($ENV.IMAGE_REPO_PREFIX + "/" + $ENV.IMAGE_NAME)
              }' \
            )
            MATRIX_JSON=$(jq --argjson build "$BUILD_JSON" '. + [$build]' <<< "$MATRIX_JSON")
          done

          echo "Generated Matrix: $MATRIX_JSON"
          COMPACT=$(jq -c '{include: .}' <<< "$MATRIX_JSON")
          echo "matrix=$COMPACT" >> "$GITHUB_OUTPUT"

  # Job to perform the actual builds based on the matrix generated above
  build-and-push:
    needs: images-to-build
    if: needs.images-to-build.outputs.should_build == 'true' && toJson(fromJson(needs.images-to-build.outputs.matrix).include) != '[]'
    runs-on: ubuntu-latest
    permissions:
      contents: read # For actions/checkout
      packages: write # For pushing images to GHCR
      id-token: write # For Sigstore/Cosign for OIDC
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.images-to-build.outputs.matrix) }}

    steps:
      - name: Checkout current repository
        if: matrix.build_type != 'external'
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Checkout external repository (${{ matrix.repo_url }})
        id: external-checkout
        if: matrix.build_type == 'external'
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          repository: ${{ matrix.repo_url }}
          ref: ${{ matrix.repo_ref }}
          fetch-depth: 0

      - name: Install Cosign
        if: needs.images-to-build.outputs.should_push == 'true'
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3.7.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: Log in to the Container registry
        if: needs.images-to-build.outputs.should_push == 'true'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Process metadata for image ${{ matrix.image }}
        id: meta
        uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893 # v5.9.0
        with:
          tags: |
            type=raw,priority=100,value=latest,enable=${{ github.ref == format('refs/heads/{0}', github.event.repository.default_branch) }}
            type=raw,priority=900,value=${{ matrix.repo_ref }}
          # type=schedule
          # # branch event
          # type=ref,enable=${{ matrix.build_type != 'external' }},priority=600,prefix=,suffix=,event=branch
          # # tag event
          # type=ref,enable=${{ matrix.build_type != 'external' }},priority=600,prefix=,suffix=,event=tag
          # # pull request event
          # type=ref,enable=${{ matrix.build_type != 'external' }},priority=600,prefix=pr-,suffix=,event=pr
          images: |
            ${{ matrix.image }}
          labels: |
            org.opencontainers.image.revision=${{ matrix.build_type == 'external' && steps.external-checkout.outputs.commit || github.sha }}
            org.opencontainers.image.url=${{ format('{0}/{1}', github.server_url, matrix.repo_url) }}
            org.opencontainers.image.title=${{ matrix.image_name }}
            org.opencontainers.image.version=${{ matrix.version }}
          annotations: |
            org.opencontainers.image.revision=${{ matrix.build_type == 'external' && steps.external-checkout.outputs.commit || github.sha }}
            org.opencontainers.image.url=${{ format('{0}/{1}', github.server_url, matrix.repo_url) }}
            org.opencontainers.image.title=${{ matrix.image_name }}
            org.opencontainers.image.version=${{ matrix.version }}

      - name: Build and push
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        id: build-and-push
        with:
          context: ${{ matrix.build_context }}
          file: ${{ matrix.dockerfile_path }}
          push: ${{ needs.images-to-build.outputs.should_push == 'true' }}
          platforms: ${{ matrix.platforms }}
          tags: ${{ join(matrix.image_tags, ',') }}
          build-args: ${{ matrix.build_args && join(matrix.build_args, '\n') || '' }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}

      - name: Sign the images with GitHub OIDC Token
        if: needs.images-to-build.outputs.should_push == 'true'
        env:
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
          TAGS: ${{ join(matrix.image_tags, ' ') }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          cosign sign --yes ${images}

      - name: Verify the signed image
        if: needs.images-to-build.outputs.should_push == 'true'
        env:
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
          TAGS: ${{ join(matrix.image_tags, ' ') }}
          REPO_PREFIX: ${{ github.repository }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          cosign verify ${images} \
          --certificate-oidc-issuer https://token.actions.githubusercontent.com \
          --certificate-identity-regexp="https://github.com/${REPO_PREFIX}" \
          -o text
